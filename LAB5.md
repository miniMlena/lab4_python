# Лабораторная работа №5 — Отладка кодовой базы проекта на Python с помощью средств отладĸи
Моисеенко Милена Алексеевна, группа М8О-101БВ-25

## Цель
- заĸрепление навыĸов работы с отладчиĸом;
- формирование понимания типовых логичесĸих и runtime-ошибоĸ;
- освоение методиĸи поисĸа, анализа и устранения ошибоĸ;
- развитие умения объяснять причину неĸорреĸтного поведения программы. Логические и runtime-ошибки

## Ошибка 1 — Неверное логическое условие при проверке существования книги

Место: `library.py`, метод `remove_book`\
Внесенная ошибка:
    
    if book not in self.book_collection:\
        self.isbn_index.remove(book)\
        self.author_index.remove(book)\
        self.year_index.remove(book)\
        self.genre_index.remove(book)
        
    self.book_collection.remove(book)

Симптом:\
При удалении книги индексы не удаляются, что приводит к несогласованности данных. Можно удалить книгу из основной коллекции, но она останется в индексах.

Как воспроизвести:
1. Запустить симуляцию с seed=42
2. На шаге 11 будет удалена книга жанра роман
3. На шаге 20 будут искаться книги жанра роман, там всё ещё будет эта книга
4. В итоговом списке книг в конце симуляции её не будет
5. Она будет найдена в индексах, но не в основной коллекции

Отладка:\
Установлен breakpoint на условие if. В отладчике видно, что выражение всегда будет False.\
Видно значение book, которое прояверяется:\
<img width="1042" height="200" alt="image" src="https://github.com/user-attachments/assets/d2b64b25-224d-4c72-bdbe-d844411bb872" />
И что эта книга ещё находится в book_collection на момент проверки:\
<img width="1041" height="379" alt="image" src="https://github.com/user-attachments/assets/fae501f2-5df6-402a-9bdd-b40968e9a0b4" />

Проблема:\
Сначала проверяется, что книги нет в коллекции (что всегда False до удаления книги), а только потом она удаляется из `book_collection`. В итоге в индексах книга остается

Причина:\
Неправильный порядок операций: проверка находится до удаления книги из коллекции.

Исправление:\
Заменено на:

    self.book_collection.remove(book)
    
    if book not in self.book_collection:\
        self.isbn_index.remove(book)\
        self.author_index.remove(book)\
        self.year_index.remove(book)\
        self.genre_index.remove(book)

Проверка:\
После исправления индексы синхронизируются с основной коллекцией. Удаленные книги больше не находятся при поиске.

Доказательства:\
До:\
<img width="940" height="472" alt="image" src="https://github.com/user-attachments/assets/06d822fa-f0ea-4c77-a6bf-cadc1e99ab15" />

После исправления:\
<img width="942" height="379" alt="image" src="https://github.com/user-attachments/assets/0fd2e22a-a388-4563-b879-f41762063f07" />

В отладке тоже видно, что проверяемая книга уже не находится в book_collection:\
<img width="1115" height="319" alt="image" src="https://github.com/user-attachments/assets/9fa74d67-2a1f-4990-8df2-0bbad4203ea4" />


## Ошибка 2 — Неправильная обработка строки при вводе отрицательного числа шагов

Место: `parse_params.py`, функция `parse_simulation_parameters`\
Внесенная ошибка:

    if key == 'steps':
        try:
            steps_int = int(value)
            # Нет проверки, что steps_int - положительное число
            steps = steps_int
        except ValueError as e:
            raise ValueError(f"Ошибка в steps: {e}")

Симптом:\
При вводе steps=-10 программа не обрабатывает это корректно и не вызывается ошибка. Симуляция завершается, не выполнив ни одного шага, но выведя начальный и итоговый набор книг.

Как воспроизвести:
1. Запустите симуляцию с steps=-10
2. Сразу после вывода начального списка книг не будет выполнено ни одного шага симуляции и выведется итоговый список книг

Отладка:\
Брейкпоинт на цикл со steps в random_simulation.py
Видим, что steps действительно равно -10, а в блоке кода до этого генерировался стартовый набор случайных книг.
<img width="1189" height="182" alt="image" src="https://github.com/user-attachments/assets/0a4d7694-6786-4e85-9674-9a117165b632" />

Причина:\
Отсутствует проверка на положительное значение steps перед запуском симуляции

Исправление:\
Заменено на:

    if key == 'steps':
        try:
            steps_int = int(value)
            if steps_int <= 0:
                raise ValueError("steps должен быть положительным числом")
            steps = steps_int```\
        except ValueError as e:
            raise ValueError(f"Ошибка в steps: {e}")

Проверка:\
Теперь выводится ошибка "steps должен быть положительным числом" и симуляция не запускается.

Доказательства:\
До:\
<img width="693" height="572" alt="image" src="https://github.com/user-attachments/assets/98f033b1-9cd5-4edb-acca-1a788ab37ebf" />

После исправления:\
<img width="504" height="66" alt="image" src="https://github.com/user-attachments/assets/9d93043e-6144-4a03-aae0-183a1f40eb60" />

В отладке тоже видно значение int_steps и выбрасываемую ошибку:\
<img width="936" height="317" alt="image" src="https://github.com/user-attachments/assets/5b4c5b6c-927c-4aab-aa48-bae03abce248" />

## Ошибка 3 — Ошибка границы цикла (Off-by-One)

Место: `random_simulation.py`, функция `run_simulation`
Внесенная ошибка:\
```for i in range(1, steps):```

Симптом:\
Выполняется на 1 меньше шагов, чем указывает пользователь.

Как воспроизвести:\
Запустите симуляцию с steps=5, seed=1

Вывод показывает 4 шага вместо 5.

Отладка:\
Брейкпоинт на for i in range(1, steps): и выводе конечного набора книг
Видим, что на момент вывода конечного набора книг i=4:\
<img width="1125" height="438" alt="image" src="https://github.com/user-attachments/assets/60dba579-85a4-4adf-8a6a-ee77a38212cc" />
То есть последний шаг номер 4.

Причина:\
Неправильный параметр в функции `range()`: используется `range(1, steps)` вместо `range(1, steps + 1)`.

Исправление:\
Заменено на:\
```for i in range(1, steps + 1):```

Проверка:\
После исправления выполняется именно столько шагов, сколько указано.

Доказательства:\
До (последний шаг - 4):\
<img width="682" height="387" alt="image" src="https://github.com/user-attachments/assets/93c63ee4-b33d-4033-b4e9-5a745835e468" />
После (последний шаг - 5):\
<img width="675" height="397" alt="image" src="https://github.com/user-attachments/assets/eba3f60e-3fce-4395-8324-36822d323beb" />

В отладчике также видно, что значение i на момент вывода конечного набора книг теперь равно 5:\
<img width="1112" height="418" alt="image" src="https://github.com/user-attachments/assets/f39769af-832b-47cb-80c9-d42573afaf4e" />


## Ошибка 4 — Сравнение через `is` вместо `==`

Место: `random_simulation.py`, функция `run_simulation`

Симптом:\
Условие `if seed:` не срабатывает при `seed=0`, так как используется оператор сравнения идентичности `is`, а не проверка значения.

Как воспроизвести:\
Запустите симуляцию с steps=5 seed=0
# Seed не устанавливается, несмотря на то что передан!
```
Отладка:\

**Код на строке 137:**
```python
if seed:  # Условие False для seed=0!
    random.seed(seed)
```

**Проблема:**
- `seed = 0` — это валидное значение для random.seed()
- Но в Python `if seed:` эквивалентно `if seed is not None and seed != 0:`
- Значение 0 считается "ложным"

**Значения переменных:**
- `seed` = 0 (целое число)
- `if seed:` = **False** (неверно! Должно быть True для seed=0)
- `random.seed(0)` не выполняется

### Причина
Использование условия `if seed:` вместо проверки `if seed is not None:` для проверки наличия параметра.

### Исправление

**ДО:**
```python
if seed:  # Не работает для seed=0!
    random.seed(seed)
```

**ПОСЛЕ:**
```python
if seed is not None:  # Правильная проверка
    random.seed(seed)
```

### Проверка
- `seed=None` → random.seed() не вызывается ✓
- `seed=0` → random.seed(0) вызывается ✓
- `seed=42` → random.seed(42) вызывается ✓

### Доказательства
- **Сценарий:** Запуск `run_simulation(steps=5, seed=0)` дважды
- **Результат до исправления:** Результаты разные (seed не установлен)
- **Результат после исправления:** Результаты идентичны (seed=0 активен)

---

## Ошибка 5 — Использование изменяемого значения по умолчанию (Mutable Default Argument)

### Место
**Файл:** `index_dict.py`, метод `ISBNIndexDict.add` (строка 66)

### Симптом
При добавлении нескольких книг с одинаковым ISBN последняя добавленная книга перезаписывает предыдущие в индексе. Это происходит потому, что используется общий объект `BookCollection` для нескольких ключей.

### Как воспроизвести
```python
lib = Library()
book1 = Book("Война и мир", "Толстой", 2020, "Роман")
book2 = Book("Преступление и наказание", "Достоевский", 2020, "Роман")
# Обе книги с разными ISBN

lib.add_book(book1)
lib.add_book(book2)

# Если случайно генерируются одинаковые ISBN...
# (вероятна при повторной генерации с seed)
# То вторая книга перезаписывает первую
```

### Отладка

**Проблемный код (строка 66-67):**
```python
def add(self, book: Book) -> None:
    if book.isbn not in self.data:
        self.data[book.isbn] = BookCollection(book)  # Создаем BookCollection с книгой
```

**Проблема:** 
При первом использовании конструктора `BookCollection(book)` в качестве значения по умолчанию, этот объект многократно переиспользуется.

**Более правильный сценарий проблемы:**
```python
# Если мы передаем книгу в конструктор BookCollection при добавлении
self.data[book.isbn] = BookCollection(book)

# Но потом при попытке добавить еще одну книгу с тем же ISBN:
if book.isbn not in self.data:  # Это уже True!
    # Мы не добавляем ее повторно
    pass
```

**Значения переменных при останове:**
- `book` = Book("Война и мир", "Толстой", 1869, "Исторический роман")
- `book.isbn` = "978-9-12345-123-5"
- `self.data[book.isbn]` = BookCollection с одной книгой

### Причина
Неправильное инициализирование новой BookCollection: конструктор вызывается с аргументом, но должен быть создан пустой объект.

### Исправление

**ДО:**
```python
def add(self, book: Book) -> None:
    if book.isbn not in self.data:
        self.data[book.isbn] = BookCollection(book)  # Может привести к проблемам!
```

**ПОСЛЕ:**
```python
def add(self, book: Book) -> None:
    if book.isbn not in self.data:
        self.data[book.isbn] = BookCollection()  # Создаем пустую коллекцию
    if book not in self.data[book.isbn]:
        self.data[book.isbn].add(book)  # Добавляем книгу отдельно
```

### Проверка
- Несколько книг с одним ISBN правильно хранятся в одной BookCollection
- При поиске по ISBN возвращаются все книги с этим ISBN
- Синхронизация с другими индексами работает корректно

### Доказательства
- **Сценарий:** Добавление нескольких книг и поиск по ISBN
- **Результат до исправления:** Потеря книг в индексе
- **Результат после исправления:** Все книги сохраняются и находятся

---

## Заключение

Все пять ошибок успешно определены, отлажены и исправлены:

1. **Ошибка 1 (Логическое условие):** Неправильный порядок проверки при удалении книги → синхронизация индексов нарушена
2. **Ошибка 2 (Разбор строки):** Отсутствие проверки пустого ввода → IndexError при пустой строке
3. **Ошибка 3 (Off-by-One):** Неправильный диапазон цикла инициализации → добавляется на 1 книгу больше
4. **Ошибка 4 (Сравнение `is`):** Использование `if seed:` вместо `if seed is not None:` → seed=0 игнорируется
5. **Ошибка 5 (Изменяемое значение):** Неправильная инициализация BookCollection в индексе → потеря данных

Рекомендуется использовать отладчик (debugger) при разработке, проверять граничные случаи (boundary cases) и тестировать с различными значениями параметров, включая нулевые и None.
